//! Integration tests for gRPC server and client
use hodei_jobs::{
    GetJobRequest, JobDefinition, QueueJobRequest, ResourceRequirements,
    job_execution_service_client::JobExecutionServiceClient,
};
use std::time::Duration;
use testcontainers::{Image, clients::Docker, core::Container};
use tonic::transport::Channel;

// =============================================================================
// Testcontainers-based Integration Tests
// =============================================================================

#[tokio::test]
async fn test_grpc_server_job_queue_integration() {
    // Initialize Docker client
    let docker = Docker::default();

    // Start PostgreSQL container
    let postgres = testcontainers_modules::postgres::Postgres::default();
    let postgres_container: Container<testcontainers_modules::postgres::Postgres> =
        docker.run(postgres);

    let postgres_port = postgres_container.get_host_port_ipv4(5432);

    // Wait for PostgreSQL to be ready
    tokio::time::sleep(Duration::from_secs(2)).await;

    // Set up environment
    std::env::set_var(
        "DATABASE_URL",
        &format!(
            "postgresql://postgres:postgres@localhost:{}/postgres",
            postgres_port
        ),
    );

    // Start the gRPC server in background
    let server_handle = tokio::spawn(async {
        // In a real test, you'd start your actual server here
        // let server = hodei_jobs_grpc::server::create_server().await.unwrap();
        // server.run().await.unwrap();
        ()
    });

    // Wait for server to start
    tokio::time::sleep(Duration::from_secs(3)).await;

    // Create client
    let channel = Channel::from_static("http://localhost:50051")
        .connect()
        .await
        .expect("Failed to connect to server");

    let mut client = JobExecutionServiceClient::new(channel);

    // Test queueing a job
    let request = QueueJobRequest {
        job_definition: Some(JobDefinition {
            job_id: Some(hodei_jobs::JobId {
                value: "test-job-123".to_string(),
            }),
            name: "test-job".to_string(),
            description: "Test job for integration".to_string(),
            command: "echo hello".to_string(),
            arguments: vec![],
            environment: std::collections::HashMap::new(),
            requirements: Some(ResourceRequirements {
                cpu_cores: 1.0,
                memory_bytes: 512 * 1024 * 1024,
                disk_bytes: 1024 * 1024 * 1024,
                gpu_count: 0,
                custom_required: std::collections::HashMap::new(),
            }),
            scheduling: None,
            selector: None,
            tolerations: vec![],
            timeout: Some(hodei_jobs::TimeoutConfig {
                execution_timeout: Some(prost_types::Duration {
                    seconds: 300,
                    nanos: 0,
                }),
                heartbeat_timeout: None,
                cleanup_timeout: None,
            }),
            tags: vec!["test".to_string()],
        }),
        queued_by: "test-user".to_string(),
    };

    let response = client
        .queue_job(request)
        .await
        .expect("Failed to queue job");

    // Verify response
    assert!(response.into_inner().success);

    // Cleanup
    server_handle.abort();
    drop(postgres_container);
}

// =============================================================================
// Mock Server for Unit Tests
// =============================================================================

use hodei_jobs::{
    QueueJobResponse,
    job_execution_service_server::{JobExecutionService, JobExecutionServiceServer},
};
use tonic::{Request, Response, Status};

#[derive(Debug, Clone, Default)]
pub struct MockJobExecutionService {
    pub jobs_queued: std::sync::Arc<std::sync::Mutex<Vec<String>>>,
}

#[tonic::async_trait]
impl JobExecutionService for MockJobExecutionService {
    async fn queue_job(
        &self,
        _request: Request<QueueJobRequest>,
    ) -> Result<Response<QueueJobResponse>, Status> {
        let job_id = format!("mock-job-{}", uuid::Uuid::new_v4());

        // Store job ID for verification
        let mut jobs = self.jobs_queued.lock().unwrap();
        jobs.push(job_id.clone());

        Ok(Response::new(QueueJobResponse {
            success: true,
            message: format!("Job queued: {}", job_id),
            queued_at: Some(prost_types::Timestamp {
                seconds: std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap()
                    .as_secs() as i64,
                nanos: 0,
            }),
        }))
    }

    async fn get_job(
        &self,
        request: Request<GetJobRequest>,
    ) -> Result<Response<hodei_jobs::GetJobResponse>, Status> {
        unimplemented!()
    }
}

#[tokio::test]
async fn test_job_queue_with_mock_server() {
    // Create mock service
    let mock_service = MockJobExecutionService::default();

    // Create server
    let addr = "127.0.0.1:0".parse().unwrap();
    let server = JobExecutionServiceServer::new(mock_service.clone());

    // Start server in background
    let server_handle = tokio::spawn(async move {
        tonic::transport::Server::builder()
            .add_service(server)
            .serve(addr)
            .await
            .unwrap();
    });

    // Wait for server to start
    tokio::time::sleep(Duration::from_millis(500)).await;

    // Create client connected to mock server
    let channel = Channel::from_shared(format!("http://127.0.0.1:{}", addr.port()))
        .unwrap()
        .connect()
        .await
        .unwrap();

    let mut client = JobExecutionServiceClient::new(channel);

    // Queue a job
    let request = QueueJobRequest {
        job_definition: Some(JobDefinition {
            job_id: Some(hodei_jobs::JobId {
                value: "mock-test-job-123".to_string(),
            }),
            name: "mock-test-job".to_string(),
            description: "Mock test job".to_string(),
            command: "echo test".to_string(),
            arguments: vec![],
            environment: std::collections::HashMap::new(),
            requirements: Some(ResourceRequirements {
                cpu_cores: 1.0,
                memory_bytes: 256 * 1024 * 1024,
                disk_bytes: 512 * 1024 * 1024,
                gpu_count: 0,
                custom_required: std::collections::HashMap::new(),
            }),
            scheduling: None,
            selector: None,
            tolerations: vec![],
            timeout: Some(hodei_jobs::TimeoutConfig {
                execution_timeout: Some(prost_types::Duration {
                    seconds: 60,
                    nanos: 0,
                }),
                heartbeat_timeout: None,
                cleanup_timeout: None,
            }),
            tags: vec!["test".to_string()],
        }),
        queued_by: "test".to_string(),
    };

    let response = client.queue_job(request).await.unwrap();

    // Verify job was queued
    assert!(response.into_inner().success);

    // Verify job was recorded by mock
    let jobs = mock_service.jobs_queued.lock().unwrap();
    assert_eq!(jobs.len(), 1);

    // Cleanup
    server_handle.abort();
}

// =============================================================================
// In-Memory Transport (for Fast Unit Tests)
// =============================================================================

#[tokio::test]
async fn test_grpc_with_in_memory_transport() {
    // Placeholder for in-memory transport tests
    // In practice, you'd use tonic's in-memory client/server transport
    // For real in-memory testing, use:
    // let server = MockServer::builder().build().await;
    // let mut client = TestClient::new(server.endpoint());

    assert!(true);
}

// =============================================================================
//grpcurl-based Testing (for manual/integration testing)
// =============================================================================

#[cfg(test)]
mod grpcurl_tests {
    use super::*;

    #[tokio::test]
    async fn test_server_responds_to_grpc_reflection() {
        // This test requires the server to be running with reflection enabled
        // Use: grpcurl -plaintext localhost:50051 list

        // Example of how you'd structure this test:
        // 1. Start server with reflection service
        // 2. Use grpcurl to call methods
        // 3. Verify responses

        assert!(true, "This would use grpcurl or reflection service");
    }
}

// =============================================================================
// Performance and Load Testing Helpers
// =============================================================================

pub struct GrpcLoadTest {
    pub client: JobExecutionServiceClient<Channel>,
    pub concurrent_tasks: usize,
    pub requests_per_task: usize,
}

impl GrpcLoadTest {
    pub fn new(channel: Channel, concurrent_tasks: usize, requests_per_task: usize) -> Self {
        Self {
            client: JobExecutionServiceClient::new(channel),
            concurrent_tasks,
            requests_per_task,
        }
    }

    pub async fn run(&self) -> Result<Vec<std::time::Duration>, Box<dyn std::error::Error>> {
        let mut handles = vec![];

        for task_id in 0..self.concurrent_tasks {
            let mut client = self.client.clone();
            let handle = tokio::spawn(async move {
                let mut durations = vec![];

                for req_id in 0..self.requests_per_task {
                    let start = std::time::Instant::now();

                    let request = QueueJobRequest {
                        job_definition: Some(JobDefinition {
                            job_id: Some(hodei_jobs::JobId {
                                value: format!("load-test-job-{}-{}", task_id, req_id),
                            }),
                            name: format!("load-test-job-{}-{}", task_id, req_id),
                            description: "Load test job".to_string(),
                            command: "echo test".to_string(),
                            arguments: vec![],
                            environment: std::collections::HashMap::new(),
                            requirements: Some(ResourceRequirements {
                                cpu_cores: 1.0,
                                memory_bytes: 256 * 1024 * 1024,
                                disk_bytes: 512 * 1024 * 1024,
                                gpu_count: 0,
                                custom_required: std::collections::HashMap::new(),
                            }),
                            scheduling: None,
                            selector: None,
                            tolerations: vec![],
                            timeout: Some(hodei_jobs::TimeoutConfig {
                                execution_timeout: Some(prost_types::Duration {
                                    seconds: 60,
                                    nanos: 0,
                                }),
                                heartbeat_timeout: None,
                                cleanup_timeout: None,
                            }),
                            tags: vec!["test".to_string()],
                        }),
                        queued_by: "load-test".to_string(),
                    };

                    let _response = client.queue_job(request).await;
                    durations.push(start.elapsed());
                }

                durations
            });
            handles.push(handle);
        }

        let mut all_durations = vec![];
        for handle in handles {
            let durations = handle.await.unwrap();
            all_durations.extend(durations);
        }

        Ok(all_durations)
    }
}

// =============================================================================
// Example Usage of Load Test
// =============================================================================

#[tokio::test]
async fn test_grpc_load_performance() {
    // Start your server here
    let channel = Channel::from_static("http://localhost:50051")
        .connect()
        .await
        .unwrap();

    let load_test = GrpcLoadTest::new(channel, 10, 100);
    let durations = load_test.run().await.unwrap();

    // Calculate statistics
    let avg_duration = durations.iter().sum::<std::time::Duration>() / durations.len() as u32;
    let max_duration = durations.iter().max().unwrap();
    let min_duration = durations.iter().min().unwrap();

    println!("Load test results:");
    println!("  Average: {:?}", avg_duration);
    println!("  Min: {:?}", min_duration);
    println!("  Max: {:?}", max_duration);

    // Assertions
    assert!(avg_duration < std::time::Duration::from_millis(100));
    assert!(*max_duration < std::time::Duration::from_secs(1));
}

// =============================================================================
// Test Fixtures and Helpers
// =============================================================================

pub struct TestFixture {
    pub server: Option<tokio::task::JoinHandle<()>>,
    pub client: Option<JobExecutionServiceClient<Channel>>,
}

impl TestFixture {
    pub async fn new() -> Self {
        // Start server with test configuration
        let server = Self::start_server().await;

        // Wait for server to be ready
        tokio::time::sleep(Duration::from_secs(1)).await;

        // Create client
        let channel = Channel::from_static("http://localhost:50051")
            .connect()
            .await
            .unwrap();
        let client = JobExecutionServiceClient::new(channel);

        Self {
            server: Some(server),
            client: Some(client),
        }
    }

    async fn start_server() -> tokio::task::JoinHandle<()> {
        tokio::spawn(async {
            // Your server startup code here
            println!("Server started for test");
        })
    }

    pub async fn queue_test_job(&mut self) -> Result<String, Box<dyn std::error::Error>> {
        let client = self.client.as_mut().unwrap();

        let request = QueueJobRequest {
            job_definition: Some(JobDefinition {
                job_id: Some(hodei_jobs::JobId {
                    value: "fixture-test-job".to_string(),
                }),
                name: "fixture-test-job".to_string(),
                description: "Fixture test job".to_string(),
                command: "echo from fixture".to_string(),
                arguments: vec![],
                environment: std::collections::HashMap::new(),
                requirements: Some(ResourceRequirements {
                    cpu_cores: 1.0,
                    memory_bytes: 256 * 1024 * 1024,
                    disk_bytes: 512 * 1024 * 1024,
                    gpu_count: 0,
                    custom_required: std::collections::HashMap::new(),
                }),
                scheduling: None,
                selector: None,
                tolerations: vec![],
                timeout: Some(hodei_jobs::TimeoutConfig {
                    execution_timeout: Some(prost_types::Duration {
                        seconds: 60,
                        nanos: 0,
                    }),
                    heartbeat_timeout: None,
                    cleanup_timeout: None,
                }),
                tags: vec!["test".to_string()],
            }),
            queued_by: "fixture".to_string(),
        };

        let response = client.queue_job(request).await?;
        Ok("fixture-test-job".to_string())
    }
}

impl Drop for TestFixture {
    fn drop(&mut self) {
        if let Some(server) = self.server.take() {
            server.abort();
        }
    }
}

#[tokio::test]
async fn test_using_fixture() {
    let mut fixture = TestFixture::new().await;

    let job_id = fixture.queue_test_job().await.unwrap();

    assert!(!job_id.is_empty());
    assert!(job_id.starts_with("job-"));
}

// =============================================================================
// Cargo.toml Dependencies Required
// =============================================================================

/*
Add these to your [dev-dependencies] in Cargo.toml:

[dev-dependencies]
# Testing framework
tokio-test = "0.4"

# Mocking and test utilities
mockall = { version = "0.12", optional = true }
tonic-build = { version = "0.11", optional = true }

# Test containers for integration tests
testcontainers = { version = "0.26", features = ["properties-config"] }
testcontainers-modules = { version = "0.14", features = ["postgres", "redis"] }

# Performance testing
criterion = { version = "0.5", features = ["async_futures"] }

# gRPC testing utilities
grpcurl = { version = "1.8", optional = true }

[features]
default = []
testing = ["mockall", "tonic-build", "grpcurl"]

# Examples of what you'd add:
# [dev-dependencies.tokio-test]
# version = "0.4"
#
# [dev-dependencies.mockall]
# version = "0.12"
#
# [dev-dependencies.testcontainers]
# version = "0.26"
# features = ["postgres"]
*/

// =============================================================================
// Additional Testing Strategies
// =============================================================================

use hodei_jobs::JobExecutionServiceClient;

pub struct GrpcTestSuite {
    pub client: JobExecutionServiceClient<Channel>,
}

impl GrpcTestSuite {
    pub fn new(channel: Channel) -> Self {
        Self {
            client: JobExecutionServiceClient::new(channel),
        }
    }

    // Helper method to test error handling
    pub async fn test_error_scenarios(&mut self) {
        // Test with invalid request
        let invalid_request = QueueJobRequest {
            job_definition: None, // This should cause an error
            queued_by: "test".to_string(),
        };

        let result = self.client.queue_job(invalid_request).await;
        assert!(result.is_err());
    }

    // Helper method to test concurrent requests
    pub async fn test_concurrent_requests(&self, num_requests: usize) {
        let mut handles = vec![];

        for i in 0..num_requests {
            let mut client = self.client.clone();
            let handle = tokio::spawn(async move {
                let request = QueueJobRequest {
                    job_definition: Some(JobDefinition {
                        job_id: Some(hodei_jobs::JobId {
                            value: format!("concurrent-job-{}", i),
                        }),
                        name: format!("concurrent-job-{}", i),
                        description: "Concurrent test job".to_string(),
                        command: "echo test".to_string(),
                        arguments: vec![],
                        environment: std::collections::HashMap::new(),
                        requirements: Some(ResourceRequirements {
                            cpu_cores: 1.0,
                            memory_bytes: 256 * 1024 * 1024,
                            disk_bytes: 512 * 1024 * 1024,
                            gpu_count: 0,
                            custom_required: std::collections::HashMap::new(),
                        }),
                        scheduling: None,
                        selector: None,
                        tolerations: vec![],
                        timeout: Some(hodei_jobs::TimeoutConfig {
                            execution_timeout: Some(prost_types::Duration {
                                seconds: 60,
                                nanos: 0,
                            }),
                            heartbeat_timeout: None,
                            cleanup_timeout: None,
                        }),
                        tags: vec!["test".to_string()],
                    }),
                    queued_by: "concurrent-test".to_string(),
                };

                client.queue_job(request).await
            });
            handles.push(handle);
        }

        for handle in handles {
            let result = handle.await.unwrap();
            assert!(result.is_ok(), "Concurrent request should succeed");
        }
    }
}

// =============================================================================
// Benchmark Tests (Optional)
// =============================================================================

// Disabled: Requires criterion crate which is not in dependencies
/*
#[cfg(test)]
mod benches {
    use super::*;
    use criterion::{Criterion, black_box, criterion_group, criterion_main};

    fn benchmark_queue_job(c: &mut Criterion) {
        // This would require setting up a test server
        c.bench_function("queue_job", |b: &mut criterion::Bencher| {
            b.iter(|| {
                // Benchmark code here
                black_box(())
            });
        });
    }

    criterion_group!(benches, benchmark_queue_job);
    criterion_main!(benches);
}
*/

// =============================================================================
// Integration Test with Real Server
// =============================================================================

#[tokio::test]
async fn full_integration_test() {
    // 1. Start database
    // 2. Start server
    // 3. Run tests
    // 4. Cleanup

    println!("This would be a full integration test");
    println!("- Start PostgreSQL with testcontainers");
    println!("- Start gRPC server");
    println!("- Run client tests");
    println!("- Verify all operations");
    println!("- Cleanup resources");
}
